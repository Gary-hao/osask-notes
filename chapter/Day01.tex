\chapter{	从计算机结构到汇编程序入门	}
\section{	先动手操作	}
\label{start}
随书附带了光盘\footnote{下载链接：http://pan.baidu.com/share/link?shareid=541099\&uk=3657658273 或自行搜索“30天自制操作系统.iso”}，给出了书中的全部示例程序，以及部分用到的工具。
\begin{quote}
打开附带光盘，里面有一个名为tolset的文件夹，把这个文件夹复制到硬盘的任意一个位置上。现在里面的东西还不多，只有3MB左右，不过以后我们自己开发的软件也都要放到这个文件夹里，所以往后它会越来越大，因此硬盘上最好留出100MB左右的剩余空间。工具安装到此结束，我们既不用修改注册表，也不用设定路径参数，就这么简单。而且以后不管什么时候，都可以把这整个文件夹移动到任何其他地方。用这些工具，我们不仅可以开发操作系统，还可以开发简单的Windows应用程序或OSASK应用程序等。
\end{quote}

示例程序在附带光盘中名为projects的目录下，只要需要的示例程序目录复制到tolset文件夹里，就可以正常运行示例程序了。

考虑到开发中使用真实的软盘很不方便，作者特意准备了一个模拟器。

\begin{quote}
我们有了这个模拟器，不用软盘，也不用终止Windows，就可以确认所开发的操作系统启动以后的动作，很方便呢。

使用模拟器的方法也非常简单，我们只需要在用!cons\_nt.bat\footnote{要根据Windows的版本决定用哪一个。后缀为9x代表是Windows 9X系统，后缀为nt的代表使用NT 架构的Windows 系统，如Windows XP 及其以后的版本，以后默认为运行cons\_nt.bat，并在后面将其简写为!cons。\par
PS：作者开发这个系统是2000年左右的事情，写书的时间也比较早，所以考虑了这些问题，可以理解哈！}（或者是!cons\_9x.bat）打开的命令行窗口中输入“run” 指令就可以了。然后一个名叫QEMU 的非常优秀的免费PC 模拟器就会自动运行。
\end{quote}

\begin{center}
\S
\end{center}

在这一节中，作者使用二进制编辑器（十六进制编辑器）做了一个helloos.img文件出来。先输入了一些内容，并把内容保存成软盘映像文件格式，将这个文件写入软盘，并用它来启动电脑。画面上会显示出“hello, world” 这个字符串。如果有兴趣，希望自己尝试，请参考书中这一小节的内容。

\section{	究竟做了些什么	}
简单解释了为什么上一节可以用二进制来写一个所谓的操作系统（虽然只能显示“hello, world” 这个字符串）。
\section{	初次体验汇编程序	}
\begin{quote}
好，现在就让我们马上来写一个汇编程序，用它来生成一个跟刚才完全一样的helloos.img吧。我们这次使用的汇编语言编译器是笔者自己开发的，名为“nask”，其中的很多语法都模仿了自由软件里享有盛名的汇编器“NASM”，不过在“NASM”的基础之上又提高了自动优化能力。
\end{quote}

\dag \footnote{源代码在随书光盘（见第\ref{start}节的说明）中的路径;另外，为了便于查看，给代码中添加了行号，导致复制文中代码不是很方便，请直接使用光盘中的源代码或手动输入。}
|projects\01_day\helloos1\|
\begin{code}[label=helloos.nas]
    DB	0xeb, 0x4e, 0x90, 0x48, 0x45, 0x4c, 0x4c, 0x4f
	DB	0x49, 0x50, 0x4c, 0x00, 0x02, 0x01, 0x01, 0x00
	DB	0x02, 0xe0, 0x00, 0x40, 0x0b, 0xf0, 0x09, 0x00
	DB	0x12, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00
	DB	0x40, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x29, 0xff
	DB	0xff, 0xff, 0xff, 0x48, 0x45, 0x4c, 0x4c, 0x4f
	DB	0x2d, 0x4f, 0x53, 0x20, 0x20, 0x20, 0x46, 0x41
	DB	0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00
	RESB	16
	DB	0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
	DB	0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
	DB	0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
	DB	0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
	DB	0xee, 0xf4, 0xeb, 0xfd, 0x0a, 0x0a, 0x68, 0x65
	DB	0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72
	DB	0x6c, 0x64, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00
	RESB	368
	DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa
	DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
	RESB	4600
	DB	0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
	RESB	1469432
\end{code}

把helloos1文件夹复制粘帖到tolset文件夹里，我们只要在用“!cons”打开的命令行窗口里输入“asm”，就可以生成helloos.img文件。在用“asm”作成img文件后，再执行“run”指令，就可以得到与刚才一样的结果。
\begin{center}
\S
\end{center}
\begin{quote}
DB指令是“data byte”的缩写，也就是往文件里直接写入1个字节的指令。

RESB指令是“reserve byte”的略写，如果想要从现在的地址开始空出10个字节来，就可以写成RESB 10，意思是我们预约了这10个字节（大家可以想象成在对号入座的火车里，预订了10个连号座位的情形）。而且nask不仅仅是把指定的地址空出来，它还会在空出来的地址上自动填入0x00，所以我们这次用这个指令就可以输出很多的0x00，省得我们自己去写18万行程序了，真是帮了个大忙。

这里还要说一下，数字的前面加上0x，就成了十六进制数，不加0x，就是十进制数。这一点跟C语言是一样的。
\end{quote}

\section{	加工润色	}
\begin{quote}
刚才我们把程序变成了短短的22行，这成果令人欣喜。不过还有一点不足就是很难看出这些程序是干什么的，所以我们下面就来稍微改写一下，让别人也能看懂。
\end{quote}

\dag |projects\01_day\helloos2|

\begin{code}[label=helloos.nas]
; hello-os
; TAB=4

; 以下这段是标准FAT12格式软盘专用的代码

        DB     0xeb, 0x4e, 0x90
        DB     "HELLOIPL"     ; 启动区的名称可以是任意的字符串（8字节）
        DW     512            ; 每个扇区（sector）的大小（必须为512字节）
        DB     1              ; 簇（cluster）的大小（必须为1个扇区）
        DW     1        ; FAT的起始位置（一般从第一个扇区开始）
        DB     2        ; FAT的个数（必须为2）
        DW     224      ; 根目录的大小（一般设成224项）
        DW     2880     ; 该磁盘的大小（必须是2880扇区）
        DB     0xf0     ; 磁盘的种类（必须是0xf0）
        DW     9        ; FAT的长度（必须是9扇区）
        DW     18       ; 1个磁道（track）有几个扇区（必须是18）
        DW     2        ; 磁头数（必须是2）
        DD     0        ; 不使用分区，必须是0
        DD     2880     ; 重写一次磁盘大小
        DB     0,0,0x29       ; 意义不明，固定
        DD     0xffffffff     ;（可能是）卷标号码
        DB     "HELLO-OS   "  ; 磁盘的名称（11字节）
        DB     "FAT12   "     ; 磁盘格式名称（8字节）
        RESB   18             ; 先空出18字节

; 程序主体
        DB     0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c
        DB     0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a
        DB     0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09
        DB     0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb
        DB     0xee, 0xf4, 0xeb, 0xfd

; 信息显示部分

        DB     0x0a, 0x0a     ; 2个换行
        DB     "hello, world"
        DB     0x0a           ; 换行
        DB     0

        RESB   0x1fe-$        ; 填写0x00,直到 0x001fe
        DB     0x55, 0xaa

; 以下是启动区以外部分的输出

        DB     0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
        RESB   4600
        DB     0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
        RESB   1469432
\end{code}

\begin{quote}
首先是“;”命令，这是个注释命令。

其次是DB指令的新用法。我们居然可以直接用它写字符串。在写字符串的时候，汇编语言会自动地查找字符串中每一个字符所对应的编码，然后把它们一个字节一个字节地排列起来。这个功能非常方便，也就是说，当我们想要变更输出信息的时候，就再也不用自己去查字符编码表了。

再有就是DW指令和DD指令，它们分别是“data word”和“data double-word”的缩写，是DB指令的“堂兄弟”。word的本意是“单词”，但在计算机汇编语言的世界里，word指的是“16位”的意思，也就是2个字节。“double-word”是“32位”的意思，也就是4个字节。
对了，差点忘记说RESB 0x1fe-\$了。这个美元符号的意思如果不讲，恐怕谁也搞不明白，它是一个变量，可以告诉我们这一行现在的字节数（如果严格来说，有时候它还会有别的意思，关于这一点我们明天再讲）。在这个程序里，我们已经在前面输出了132字节，所以这里的\$就是132。因此nask先用0x1fe减去132，得出378这一结果，然后连续输出378个字节的0x00。

那这里我们为什么不直接写378，而非要用\$呢？这是因为如果将显示信息从“hello, world”变成“this is a pen.”的话，中间要输出0x00的字节数也会随之变化。换句话说，我们必须保证软盘的第510字节（即第0x1fe字节）开始的地方是55 AA。如果在程序里使用美元符号（\$）的话，汇编语言会自动计算需要输出多少个00，我们也就可以很轻松地改写输出信息了。
\end{quote}